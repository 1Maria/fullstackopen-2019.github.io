{"data":{"markdownRemark":{"html":"<h2>React</h2>\n<p>Alamme nyt tutustua kurssin ehkä tärkeimpään teemaan, <a href=\"https://reactjs.org/\">React</a>-kirjastoon. Tehdään heti yksinkertainen React-sovellus ja tutustutaan samalla Reactin peruskäsitteistöön.</p>\n<p>Ehdottomasti helpoin tapa päästä alkuun on <a href=\"https://github.com/facebookincubator/create-react-app\">create-react-app</a>-nimisen työkalun käyttö. <em>create-react-app</em> on mahdollista asentaa, mutta asennukseen ei ole tarvetta jos Noden mukana asentunut <em>npm</em>-työkalu on versioltaan vähintään <em>5.3</em>. Tällöin npm:n mukana asentuu komento <em>npx</em>, joka mahdollistaa create-react-app:in käytön asentamatta sitä erikseen. Npm:n version saa selville komennolla <em>npm -v</em>.</p>\n<p>Luodaan sovellus nimeltään <em>osa1</em> ja käynnistetään se:</p>\n<pre>\n$ npx create-react-app osa1\n$ cd osa1\n$ npm start\n</pre>\n<p>Sovellus käynnistyy oletusarvoisesti localhostin porttiin 3000, eli osoitteeseen <a href=\"http://localhost:3000\">http://localhost:3000</a></p>\n<p>Chromen pitäisi aueta automaattisesti. Avaa konsoli <strong>välittömästi</strong>. Avaa myös tekstieditori siten, että näet koodin ja web-sivun samaan aikaan ruudulla:</p>\n<picture><img src=\"/static/81904ddb14b48b3eddd84cfb2a8cd9db/14be6/26.png\" srcset=\"/static/81904ddb14b48b3eddd84cfb2a8cd9db/4cce7/26.png 200w,\n/static/81904ddb14b48b3eddd84cfb2a8cd9db/bae5f/26.png 400w,\n/static/81904ddb14b48b3eddd84cfb2a8cd9db/14be6/26.png 800w,\n/static/81904ddb14b48b3eddd84cfb2a8cd9db/1b35a/26.png 1200w,\n/static/81904ddb14b48b3eddd84cfb2a8cd9db/9ee03/26.png 1600w,\n/static/81904ddb14b48b3eddd84cfb2a8cd9db/2361e/26.png 2078w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Sovelluksen koodi on hakemistossa <em>src</em>. Yksinkertaistetaan valmiina olevaa koodia siten, että tiedoston <em>index.js</em> sisällöksi tulee:</p>\n<pre><code class=\"language-react\">import React from 'react'\nimport ReactDOM from 'react-dom'\n\nconst App = () => (\n  &#x3C;div>\n    &#x3C;p>Hello world&#x3C;/p>\n  &#x3C;/div>\n)\n\nReactDOM.render(&#x3C;App />, document.getElementById('root'))\n</code></pre>\n<p>Voit poistaa tiedostot <em>App.js</em>, <em>App.css</em>, <em>App.test.js</em>, <em>logo.svg</em> ja <em>registerServiceWorker.js</em></p>\n<h3>Komponentti</h3>\n<p>Tiedosto <em>index.js</em> määrittelee nyt React-<a href=\"https://reactjs.org/docs/components-and-props.html\">komponentin</a> nimeltään <em>App</em> ja viimeisen rivin komento</p>\n<pre><code class=\"language-react\">ReactDOM.render(&#x3C;App />, document.getElementById('root'))\n</code></pre>\n<p>renderöi komponentin sisällön tiedoston <em>public/index.html</em> määrittelemään <em>div</em>-elementtiin, jonka <em>id:n</em> arvona on 'root'</p>\n<p>Tiedosto <em>public/index.html</em> on oleellisesti ottaen tyhjä, voit kokeilla lisätä sinne HTML:ää. Reactilla ohjelmoitaessa yleensä kuitenkin kaikki renderöitävä sisältö määritellään Reactin komponenttien avulla.</p>\n<p>Tarkastellaan vielä tarkemmin komponentin määrittelevää koodia:</p>\n<pre><code class=\"language-react\">const App = () => (\n  &#x3C;div>\n    &#x3C;p>Hello world&#x3C;/p>\n  &#x3C;/div>\n)\n</code></pre>\n<p>Kuten arvata saattaa, komponentti renderöityy <em>div</em>-tagina, jonka sisällä on <em>p</em>-tagin sisällä oleva teksti <em>Hello world</em>.</p>\n<p>Teknisesti ottaen komponentti on määritelty Javascript-funktiona. Seuraava siis on funktio (joka ei saa yhtään parametria):</p>\n<pre><code class=\"language-react\">() => (\n  &#x3C;div>\n    &#x3C;p>Hello world&#x3C;/p>\n  &#x3C;/div>\n)\n</code></pre>\n<p>joka sijoitetaan vakioarvoiseen muuttujaan <em>App</em></p>\n<pre><code class=\"language-js\">const App = ...\n</code></pre>\n<p>Javascriptissa on muutama tapa määritellä funktioita. Käytämme nyt Javascriptin hieman uudemman version <a href=\"http://es6-features.org/#Constants\">EcmaScript 6:n</a> eli ES6:n <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">nuolifunktiota</a> (arrow functions).</p>\n<p>Koska funktio koostuu vain yhdestä lausekkeesta, on käytössämme lyhennysmerkintä, joka vastaa oikeasti seuraavaa koodia:</p>\n<pre><code class=\"language-react\">const App = () => {\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello world&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>eli funktio palauttaa sisältämänsä lausekkeen arvon.</p>\n<p>Komponentin määrittelevä funktio voi sisältää mitä tahansa Javascript-koodia. Muuta komponenttisi seuraavaan muotoon ja katso mitä konsolissa tapahtuu:</p>\n<pre><code class=\"language-react\">const App = () => {\n  console.log('Hello from komponentti')\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello world&#x3C;/p>\n    &#x3C;/div>\n  )}\n</code></pre>\n<p>Komponenttien sisällä on mahdollista renderöidä myös dynaamista sisältöä.</p>\n<p>Muuta komponentti muotoon:</p>\n<pre><code class=\"language-react\">const App = () => {\n  const now = new Date()\n  const a = 10\n  const b = 20\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello world, it is {now.toString()}&#x3C;/p>\n      &#x3C;p>{a} plus {b} is {a + b}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Aaltosulkeiden sisällä oleva Javascript-koodi evaluoidaan ja evaluoinnin tulos upotetaan määriteltyyn kohtaan komponentin tuottamaa HTML-koodia.</p>\n<h3>JSX</h3>\n<p>Näyttää siltä, että React-komponentti palauttaa HTML-koodia. Näin ei kuitenkaan ole. React-komponenttien ulkoasu kirjoitetaan yleensä <a href=\"https://reactjs.org/docs/introducing-jsx.html\">JSX</a>:ää käyttäen. Vaikka JSX näyttää HTML:ltä, kyseessä on kuitenkin tapa kirjoittaa Javascriptiä. React komponenttien palauttama JSX käännetään konepellin alla Javascriptiksi.</p>\n<p>Käännösvaiheen jälkeen ohjelmamme näyttää seuraavalta:</p>\n<pre><code class=\"language-js\">import React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () => {\n  const now = new Date();\n  const a = 10;\n  const b = 20;\n  return React.createElement(\n    'div',\n    null,\n    React.createElement('p', null, 'Hello world, it is ', now.toString()),\n    React.createElement('p', null, a, ' plus ', b, ' is ', a + b)\n  );\n};\n\nReactDOM.render(\n  React.createElement(App, null),\n  document.getElementById('root')\n);\n</code></pre>\n<p>Käännöksen hoitaa <a href=\"https://babeljs.io/repl/\">Babel</a>. Create-react-app:illa luoduissa projekteissa käännös on konfiguroitu tapahtumaan automaattisesti. Tulemme tutustumaan aiheeseen tarkemmin kurssin <a href=\"/osa7\">osassa 7</a>.</p>\n<p>Reactia olisi myös mahdollista kirjoittaa \"suoraan Javascriptinä\" käyttämättä JSX:ää. Kukaan täysijärkinen ei kuitenkaan niin tee.</p>\n<p>Käytännössä JSX on melkein kuin HTML:ää sillä erotuksella, että mukaan voi upottaa helposti dynaamista sisältöä kirjoittamalla sopivaa Javascriptiä aaltosulkeiden sisälle. Idealtaan JSX on melko lähellä monia palvelimella käytettäviä templating-kieliä kuten Java Springin yhteydessä käytettävää thymeleafia.</p>\n<p>JSX on \"XML:n kaltainen\", eli jokainen tagi tulee sulkea. Esimerkiksi rivinvaihto on tyhjä elementti, joka kirjoitetaan HTML:ssä tyypillisesti</p>\n<pre><code class=\"language-html\">&#x3C;br />\n</code></pre>\n<p>mutta JSX:ää kirjoittaessa tagi on pakko sulkea:</p>\n<pre><code class=\"language-html\">&#x3C;br />\n</code></pre>\n<h2>Monta komponenttia</h2>\n<p>Muutetaan sovellusta seuraavasti (yläreunan importit jätetään <em>esimerkeistä</em> nyt ja jatkossa pois):</p>\n<pre><code class=\"language-react\">const Hello = () => {\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello world&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n\nconst App = () => {\n  return (\n    &#x3C;div>\n      &#x3C;h1>Greetings&#x3C;/h1>\n      &#x3C;Hello />\n    &#x3C;/div>\n  )\n}\n\nReactDOM.render(&#x3C;App />, document.getElementById('root'))\n</code></pre>\n<p>Olemme määritelleet uuden komponentin <em>Hello</em>, jota käytetään komponentista <em>App</em>. Komponenttia voidaan luonnollisesti käyttää monta kertaa:</p>\n<pre><code class=\"language-react\">const App = () => {\n  return (\n    &#x3C;div>\n      &#x3C;h1>Greetings&#x3C;/h1>\n      &#x3C;Hello />\n      &#x3C;Hello />\n      &#x3C;Hello />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Komponenttien tekeminen Reactissa on helppoa ja komponentteja yhdistelemällä monimutkaisempikin sovellus on mahdollista pitää kohtuullisesti ylläpidettävänä. Reactissa filosofiana onkin koostaa sovellus useista, pieneen asiaan keskittyvistä uudelleenkäytettävistä komponenteista.</p>\n<h2>props: tiedonvälitys komponenttien välillä</h2>\n<p>Komponenteille on mahdollista välittää dataa <a href=\"https://reactjs.org/docs/components-and-props.html\">propsien</a> avulla.</p>\n<p>Muutetaan komponenttia <em>Hello</em> seuraavasti</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {props.name}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>komponentin määrittelevällä funktiolla on nyt parametri <em>props</em>. Parametri saa arvokseen olion, jonka kenttinä ovat kaikki eri \"propsit\", jotka komponentin käyttäjä määrittelee.</p>\n<p>Propsit määritellään seuraavasti:</p>\n<pre><code class=\"language-react\">const App = () => {\n  return (\n    &#x3C;div>\n      &#x3C;h1>Greetings&#x3C;/h1>\n      &#x3C;Hello name=\"Arto\" />\n      &#x3C;Hello name=\"Pekka\" />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Propseja voi olla mielivaltainen määrä ja niiden arvot voivat olla \"kovakoodattuja\" merkkijonoja tai Javascript-lausekkeiden tuloksia. Jos propsin arvo muodostetaan Javascriptillä, tulee se olla aaltosulkeissa.</p>\n<p>Muutetaan koodia siten, että komponentti <em>Hello</em> käyttää kahta propsia:</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {props.name}, you are {props.age} years old&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n\nconst App = () => {\n  const nimi = 'Pekka'\n  const ika = 10\n  return (\n    &#x3C;div>\n      &#x3C;h1>Greetings&#x3C;/h1>\n      &#x3C;Hello name=\"Arto\" age={26 + 10} />\n      &#x3C;Hello name={nimi} age={ika} />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Komponentti <em>App</em> lähettää propseina muuttujan arvoja, summalausekkeen evaluoinnin tuloksen ja normaalin merkkijonon.</p>\n<h3>Muutama huomio</h3>\n<p>React on konfiguroitu antamaan varsin hyviä virheilmoituksia. Kannattaa kuitenkin edetä ainakin alussa <strong>todella pienin askelin</strong> ja varmistaa, että jokainen muutos toimii halutulla tavalla.</p>\n<p><strong>Konsolin tulee olla koko ajan auki</strong>. Jos selain ilmoittaa virheestä, ei kannata kirjoittaa sokeasti lisää koodia ja toivoa ihmettä tapahtuvaksi, vaan tulee yrittää ymmärtää virheen syy ja esim. palata edelliseen toimivaan tilaan:</p>\n<picture><img src=\"/static/854b6febc93da9290aba42acc284146a/14be6/27.png\" srcset=\"/static/854b6febc93da9290aba42acc284146a/4cce7/27.png 200w,\n/static/854b6febc93da9290aba42acc284146a/bae5f/27.png 400w,\n/static/854b6febc93da9290aba42acc284146a/14be6/27.png 800w,\n/static/854b6febc93da9290aba42acc284146a/c106c/27.png 1096w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Kannattaa myös muistaa, että React-koodissakin on mahdollista ja kannattavaa lisätä koodin sekaan sopivia konsoliin tulostavia <code>console.log()</code>-komentoja. Tulemme hieman <a href=\"#react-sovellusten-debuggaus\">myöhemmin</a> tutustumaan muutamiin muihinkin tapoihin debugata Reactia.</p>\n<p>Kannattaa pitää mielessä, että <strong>React-komponenttien nimien tulee alkaa isolla kirjaimella</strong>. Jos yrität määritellä komponentin seuraavasti:</p>\n<pre><code class=\"language-react\">const footer = () => {\n  return (\n    &#x3C;div>greeting app created by &#x3C;a href=\"https://github.com/mluukkai\">mluukkai&#x3C;/a>&#x3C;/div>\n  )\n}\n</code></pre>\n<p>ja ottaa se käyttöön</p>\n<pre><code class=\"language-react\">const App = () => {\n  return (\n    &#x3C;div>\n      &#x3C;h1>Greetings&#x3C;/h1>\n      &#x3C;Hello name=\"Arto\" age={26 + 10} />\n      &#x3C;footer />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>sivulle ei kuitenkaan ilmesty näkyviin Footer-komponentissa määriteltyä sisältöä, vaan React luo sivulle ainoastaan tyhjän <em>footer</em>-elementin. Jos muutat komponentin nimen alkamaan isolla kirjaimella, React luo sivulle <em>div</em>-elementin, joka määriteltiin Footer-komponentissa.</p>\n<p>Kannattaa myös pitää mielessä, että React-komponentin sisällön tulee (yleensä) sisältää <strong>yksi juurielementti</strong>. Eli jos yrittäisimme määritellä komponentin <em>App</em> ilman uloimmaista <em>div</em>-elementtiä:</p>\n<pre><code class=\"language-react\">const App = () => {\n  return (\n    &#x3C;h1>Greetings&#x3C;/h1>\n    &#x3C;Hello name=\"Arto\" age={26 + 10} />\n    &#x3C;Footer />\n  )\n}\n</code></pre>\n<p>seurauksena on virheilmoitus:</p>\n<picture><img src=\"/static/2a1426bc8c0c16b7768cd5615f9c1ebb/14be6/27a.png\" srcset=\"/static/2a1426bc8c0c16b7768cd5615f9c1ebb/4cce7/27a.png 200w,\n/static/2a1426bc8c0c16b7768cd5615f9c1ebb/bae5f/27a.png 400w,\n/static/2a1426bc8c0c16b7768cd5615f9c1ebb/14be6/27a.png 800w,\n/static/2a1426bc8c0c16b7768cd5615f9c1ebb/aebbb/27a.png 1184w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Reactin versiosta 0.16 asti juurielementin käyttö ei ole ollut enää ainoa toimiva vaihtoehto, myös <em>taulukollinen</em> komponentteja on validi tapa:</p>\n<pre><code class=\"language-react\">const App = () => {\n  return (\n    [\n      &#x3C;h1>Greetings&#x3C;/h1>,\n      &#x3C;Hello name=\"Arto\" age={26 + 10} />,\n      &#x3C;Footer />\n    ]\n  )\n}\n</code></pre>\n<p>Määritellessä sovelluksen juurikomponenttia, tämä ei kuitenkaan ole järkevää ja näyttää koodissakin pahalta.</p>\n<h3>React-tehtävät, osa 1</h3>\n<p>Tee nyt <a href=\"/teht%C3%A4v%C3%A4t#reactin-alkeet\">tehtävät 1.1 ja 1.2</a></p>\n<h2>Javascriptiä</h2>\n<p>Kurssin aikana on websovelluskehityksen rinnalla tavoite ja tarve oppia riittävässä määrin Javascriptiä.</p>\n<p>Javascript on kehittynyt viime vuosina nopeaan tahtiin, ja käytämme kurssilla kielen uusimpien versioiden piirteitä, joista osa ei ole vielä edes ehtinyt kielen viimeisimpään standardoituun versioon. Javascript-standardin virallinen nimi on <a href=\"https://en.wikipedia.org/wiki/ECMAScript\">ECMAScript</a>. Tämän hetken tuorein versio on kesäkuussa 2017 julkaistu <a href=\"https://www.ecma-international.org/publications/standards/Ecma-262.htm\">ES8</a>, toiselta nimeltään ECMAScript 2017.</p>\n<p>Selaimet eivät vielä osaa kaikkia Javascriptin uusimpien versioiden ominaisuuksia. Tämän takia selaimessa suoritetaan useimmiten koodia joka on käännetty (englanniksi <em>transpiled</em>) uudemmasta Javascriptin versiosta johonkin vanhempaan, laajemmin tuettuun versioon.</p>\n<p>Tällä hetkellä johtava tapa tehdä transpilointi on <a href=\"https://babeljs.io/\">Babel</a>. Create-react-app:in avulla luoduissa React-sovelluksissa on valmiiksi konfiguroitu automaattinen transpilaus. Katsomme kurssin <a href=\"/osa7\">osassa 7</a> tarkemmin miten transpiloinnin konfigurointi tapahtuu.</p>\n<p><a href=\"https://nodejs.org/en/\">Node.js</a> on melkein missä vaan, mm. palvelimilla toimiva, Googlen <a href=\"https://developers.google.com/v8/\">chrome V8</a>-javascriptmoottoriin perustuva Javascript-suoritusympäristö. Harjoitellaan hieman Javascriptiä Nodella. Tässä oletetaan, että koneellasi on Node.js:stä vähintään versio <em>v8.6.0</em>. Noden tuoreet versiot osaavat suoraan Javascriptin uusia versioita, joten koodin transpilaus ei ole tarpeen.</p>\n<p>Koodi kirjoitetaan <em>.js-</em>päätteiseen tiedostoon, ja suoritetaan komennolla <code>node tiedosto.js</code></p>\n<p>Koodia on mahdollisuus kirjoittaa myös Node.js-konsoliin, joka aukeaa kun kirjoitat komentorivillä <em>node</em> tai myös selaimen developer toolin konsoliin. Chromen uusimmat versiot osaavat suoraan transpiloimatta <a href=\"http://kangax.github.io/compat-table/es6/\">melko hyvin</a> Javascriptin uusiakin piirteitä.</p>\n<p>Javascript muistuttaa nimensä ja syntaksinsa puolesta läheisesti Javaa. Perusmekanismeiltaan kielet kuitenkin poikkeavat radikaalisti. Java-taustalta tultaessa Javascriptin käyttäytyminen saattaa aiheuttaa hämmennystä, varsinkin jos kielen piirteistä ei viitsitä ottaa selvää.</p>\n<p>Tietyissä piireissä on myös ollut suosittua yrittää \"simuloida\" Javascriptilla eräitä Javan piirteitä ja ohjelmointitapoja. En suosittele.</p>\n<h3>Muuttujat</h3>\n<p>Javascriptissä on muutama tapa määritellä muuttujia:</p>\n<pre><code class=\"language-js\">const x = 1;\nlet y = 5;\n\nconsole.log(x, y); // tulostuu 1, 5\ny += 10;\nconsole.log(x, y); // tulostuu 1, 15\ny = 'teksti';\nconsole.log(x, y); // tulostuu 1, teksti\nx = 4; // aiheuttaa virheen\n</code></pre>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const\">const</a> ei oikeastaan määrittele muuttujaa vaan <em>vakion</em>, jonka arvoa ei voi enää muuttaa. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\">let</a> taas määrittelee normaalin muuttujan.</p>\n<p>Esimerkistä näemme myös, että muuttujan tallettaman tiedon tyyppi voi vaihtaa tyyppiä suorituksen aikana, <em>y</em> tallettaa aluksi luvun ja lopulta merkkijonon.</p>\n<p>Javascriptissa on myös mahdollista määritellä muuttujia avainsanan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var\">var</a> avulla. Var oli pitkään ainoa tapa muuttujien määrittelyyn, const ja let tulivat kieleen mukaan vasta versiossa ES6. Var toimii tietyissä tilanteissa <a href=\"https://medium.com/craft-academy/javascript-variables-should-you-use-let-var-or-const-394f7645c88f\">eri</a> <a href=\"http://www.jstips.co/en/javascript/keyword-var-vs-let/\">tavalla</a> kuin useimpien muiden kielien muuttujien määrittely. Tällä kurssilla varin käyttö ei ole suositeltavaa eli käytä aina const:ia tai let:iä!</p>\n<p>Lisää aiheesta esim. youtubessa <a href=\"https://youtu.be/sjyJBL5fkp8\">var, let and const - ES6 JavaScript Features</a></p>\n<h3>Taulukot</h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Taulukko</a> ja muutama esimerkki sen käytöstä</p>\n<pre><code class=\"language-js\">const t = [1, -1, 3];\n\nt.push(5);\n\nconsole.log(t.length); // tulostuu 4\nconsole.log(t[1]); // tulostuu -1\n\nt.forEach(luku => {\n  console.log(luku); // tulostuu 1, -1, 3 ja 5 omille riveilleen\n});\n\nt[6] = 99;\n\nconsole.log(t); // tulostuu [ 1, -1, 3, 5, &#x3C;2 empty items>, 99 ]\n</code></pre>\n<p>Huomattavaa esimerkissä on se, että taulukon sisältöä voi muuttaa vaikka sen on määritelty <em>const</em>:ksi. Koska taulukko on olio,\nviittaa muuttuja koko ajan samaan olioon. Olion sisältö muuttuu sitä mukaa kuin taulukkoon lisätään uusia alkioita.</p>\n<p>Eräs tapa käydä taulukon alkiot läpi on esimerkissä käytetty <em>forEach</em>, joka saa parametrikseen nuolisyntaksilla määritellyn <em>funktion</em></p>\n<pre><code class=\"language-js\">luku => {\n  console.log(luku);\n};\n</code></pre>\n<p>forEach kutsuu funktiota <em>jokaiselle taulukon alkiolle</em> antaen taulukon alkion aina parametrina. forEachin parametrina oleva funktio voi saada myös <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\">muita parametreja</a>.</p>\n<p>Taulukoille on määritelty runsaasti hyödyllisiä operaatioita. Katsotaan pieni esimerkki operaation <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">map</a> käytöstä.</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3, 4];\n\nconst m1 = t.map(luku => luku * 2);\nconsole.log(m1); // tulostuu [2, 4, 6, 8]\n\nconst m2 = t.map(luku => '&#x3C;li>' + luku + '&#x3C;/li>');\nconsole.log(m2); // tulostuu [ '&#x3C;li>1&#x3C;/li>', '&#x3C;li>2&#x3C;/li>', '&#x3C;li>3&#x3C;/li>', '&#x3C;li>4&#x3C;/li>' ]\n</code></pre>\n<p>Map siis muodostaa taulukon perusteella <em>uuden taulukon</em>, jonka jokainen alkio muodostetaan map:in parametrina olevan funktion avulla. Kuten tulemme kurssin <a href=\"/osa2\">osassa2</a> näkemään, mapia käytetään Reactissa todella usein.</p>\n<p>Taulukon yksittäisiä alkioita on helppo sijoittaa muuttujiin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destrukturoivan</a> sijoituslauseen avulla:</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3, 4, 5];\n\nconst [eka, toka, ...loput] = t;\n\nconsole.log(eka, toka); // tulostuu 1, 2\nconsole.log(loput); // tulostuu [3, 4 ,5]\n</code></pre>\n<p>Eli muuttujiin <em>eka</em> ja <em>toka</em> tulee sijoituksen ansiosta taulukon kaksi ensimmäistä lukua. Muuttujaan <em>loput</em> \"kerätään\" sijoituksesta jäljellejääneet luvut omaksi taulukoksi.</p>\n<h3>Oliot</h3>\n<p>Javasriptissa on muutama tapa määritellä olioita. Erittäin yleisesti käytetään <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals\">olioliteraaleja</a>, eli määritellään olio luettelemalla sen kentät (englanniksi property) aaltosulkeiden sisällä:</p>\n<pre><code class=\"language-js\">const olio1 = {\n  nimi: 'Arto Hellas',\n  ika: 35,\n  koulutus: 'Filosofian tohtori',\n};\n\nconst olio2 = {\n  nimi: 'Full Stack -websovelluskehitys',\n  taso: 'aineopinto',\n  laajuus: 5,\n};\n\nconst olio3 = {\n  nimi: {\n    etunimi: 'Jami',\n    sukunimi: 'Kousa',\n  },\n  arvosanat: [2, 3, 5, 3],\n  laitos: 'TKTL',\n};\n</code></pre>\n<p>Kenttien arvot voivat olla tyypiltään mitä vaan, lukuja, merkkijonoja, taulukoita, olioita...</p>\n<p>Olioiden kenttiin viitataan pistenotaatiolla, tai hakasulkeilla:</p>\n<pre><code class=\"language-js\">console.log(olio1.nimi); // tulostuu Arto Hellas\nconst kentanNimi = 'ika';\nconsole.log(olio1[kentanNimi]); // tulostuu 35\n</code></pre>\n<p>Olioille voidaan lisätä kenttiä myös lennossa joko pistenotaation tai hakasulkeiden avulla:</p>\n<pre><code class=\"language-js\">olio1.osoite = 'Tapiola';\nolio1['salainen numero'] = 12341;\n</code></pre>\n<p>Jälkimmäinen lisäyksistä on pakko tehdä hakasulkeiden avulla, sillä pistenotaatiota käytettäessä 'salainen numero' ei kelpaa kentän nimeksi.</p>\n<p>Javascriptissä olioilla voi luonnollisesti olla myös metodeja. Palaamme aiheeseen funktioiden käsittelyn jälkeen.</p>\n<p>Olioita on myös mahdollista määritellä ns. konstruktorifunktioiden avulla, jolloin saadaan aikaan hieman monien ohjelmointikielten, esim. Javan luokkia (class) muistuttava mekanismi. Javascriptissä ei kuitenkaan ole luokkia samassa mielessä kuin olio-ohjelmointikielissä. Kieleen on kuitenkin lisätty versiosta ES6 alkaen <em>luokkasyntaksi</em>, joka helpottaa tietyissä tilanteissa olio-ohjelmointikielimäisten luokkien esittämistä. Palaamme asiaan hetken kuluttua.</p>\n<p>Reactissa konstruktorifunktioihin perustuvalle olioiden määrittelylle ei ole kovin usein tarvetta, joten sivuutamme sen tällä kurssilla.</p>\n<h3>Funktiot</h3>\n<p>Olemme jo tutustuneet ns. nuolifunktioiden määrittelyyn. Täydellinen eli \"pitkän kaavan\" mukaan menevä tapa nuolifunktion määrittelyyn on seuraava</p>\n<pre><code class=\"language-js\">const summa = (p1, p2) => {\n  console.log(p1);\n  console.log(p2);\n  return p1 + p2;\n};\n</code></pre>\n<p>ja funktiota kutsutaan kuten olettaa saattaa</p>\n<pre><code class=\"language-js\">const vastaus = summa(1, 5);\nconsole.log(vastaus);\n</code></pre>\n<p>Jos parameteja on vain yksi, voidaan sulut jättää määrittelystä pois:</p>\n<pre><code class=\"language-js\">const nelio = p => {\n  console.log(p);\n  return p * p;\n};\n</code></pre>\n<p>Jos funktio sisältää ainoastaan yhden lausekkeen, ei aaltosulkeita tarvita. Tällöin funktio palauttaa ainoan lausekkeensa arvon. Eli edellinen voitaisiin ilmaista lyhyemmin seuraavasti:</p>\n<pre><code class=\"language-js\">const nelio = p => p * p;\n</code></pre>\n<p>Tämä muoto on erityisen kätevä käsiteltäessä taulukkoja esim. map-metodin avulla:</p>\n<pre><code class=\"language-js\">const t = [1, 2, 3];\nconst tnelio = t.map(p => p * p);\n// tnelio on nyt [1, 4, 9]\n</code></pre>\n<p>Nuolifunktio on tullut Javascriptiin vasta muutama vuosi sitten version <a href=\"http://es6-features.org/\">ES6</a> myötä. Tätä ennen ja paikoin nykyäänkin funktioiden määrittely tapahtui avainsanan <em>function</em> avulla.</p>\n<p>Määrittelytapoja on kaksi, funktiolle voidaan antaa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function\">function declaration</a> -tyyppisessä määrittelyssä <em>nimi</em> jonka avulla funktioon voidaan viitata:</p>\n<pre><code class=\"language-js\">function tulo(a, b) {\n  return a * b;\n}\n\nconst vastaus = tulo(2, 6);\n</code></pre>\n<p>Toinen tapa on tehdä määrittely <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">funktiolausekkeena</a>. Tällöin funktiolle ei tarvitse antaa nimeä ja määrittely voi sijaita muun koodin seassa:</p>\n<pre><code class=\"language-js\">const keskiarvo = function(a, b) {\n  return (a + b) / 2;\n};\n\nconst vastaus = keskiarvo(2, 5);\n</code></pre>\n<h3>Tehtäviä javascriptistä</h3>\n<p>Tee nyt <a href=\"/teht%C3%A4v%C3%A4t#javascriptin-alkeet\">tehtävät 1.3-1.5</a></p>\n<h3>Olioiden metodit ja this</h3>\n<p>Kaikille kolmelle tavalle määritellä funktio on oma paikkansa.</p>\n<p>Nuolifunktiot ja avainsanan <em>function</em> avulla määritellyt funktiot kuitenkin poikkeavat radikaalisti siitä miten ne käyttäytyvät avainsanan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">this</a> suhteen.</p>\n<p>Voimme liittää oliolle metodeja määrittelemällä niille kenttiä, jotka ovat funktioita:</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  ika: 35,\n  koulutus: 'Filosofian tohtori',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n};\n\narto.tervehdi(); // tulostuu hello, my name is Arto Hellas\n</code></pre>\n<p>metodeja voidaan liittää olioille myös niiden luomisen jälkeen:</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  ika: 35,\n  koulutus: 'Filosofian tohtori',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n};\n\narto.vanhene = function() {\n  this.ika += 1;\n};\n\nconsole.log(arto.ika); // tulostuu 35\narto.vanhene();\nconsole.log(arto.ika); // tulostuu 36\n</code></pre>\n<p>Muutetaan oliota hiukan</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n  laskeSumma: function(a, b) {\n    console.log(a + b);\n  },\n};\n\narto.laskeSumma(1, 4); // tulostuu 5\n\nconst viiteSummaan = arto.laskeSumma;\nviiteSummaan(10, 15); // tulostuu 25\n</code></pre>\n<p>Oliolla on nyt metodi <em>laskeSumma</em>, joka osaa laskea parametrina annettujen lukujen summan. Metodia voidaan kutsua normaaliin tapaan olion kautta <code>arto.laskeSumma(1, 4)</code> tai tallettamalla <em>metodiviite</em> muuttujaan ja kutsumalla metodia muuttujan kautta <code>viiteSummaan(10, 15)</code>.</p>\n<p>Jos yritämme samaa metodille <em>tervehdi</em>, aiheutuu ongelmia:</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n  laskeSumma: function(a, b) {\n    console.log(a + b);\n  },\n};\n\narto.tervehdi(); // tulostuu hello, my name is Arto Hellas\n\nconst viiteTervehdykseen = arto.tervehdi;\nviiteTervehdykseen(); // tulostuu hello, my name is undefined\n</code></pre>\n<p>Kutsuttaessa metodia viitteen kautta, on metodi kadottanut tiedon siitä mikä oli alkuperäinen <em>this</em>. Toisin kuin melkein kaikissa muissa kielissä, Javascriptissa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">this</a>:n arvo määrittyy sen mukaan <em>miten metodia on kutsuttu</em>. Kutsuttaessa metodia viitteen kautta, <em>this</em>:in arvoksi tulee ns. <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Global_object\">globaali objekti</a> ja lopputulos ei ole yleensä ollenkaan se, mitä sovelluskehittäjä olettaa.</p>\n<p>This:in kadottaminen aiheuttaa Reactilla ja Node.js:lla ohjelmoidessa monia potentiaalisia ongelmia. Eteen tulee erittäin usein tilanteita, missä Reactin/Noden (oikeammin ilmaistuna selaimen Javascript-moottorin) tulee kutsua joitain käyttäjän määrittelemien olioiden metodeja. Tälläinen tilanne tulee esim. jos pyydetään Artoa tervehtimään sekunnin kuluttua metodia <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\">setTimeout</a> hyväksikäyttäen.</p>\n<pre><code class=\"language-js\">const arto = {\n  nimi: 'Arto Hellas',\n  tervehdi: function() {\n    console.log('hello, my name is', this.nimi);\n  },\n};\n\nsetTimeout(arto.tervehdi, 1000);\n</code></pre>\n<p>Javascriptissa this:in arvo siis määräytyy siitä miten metodia on kutsuttu. setTimeoutia käytettäessä metodia kutsuu Javascript-moottori ja this viittaa Timeout-olioon.</p>\n<p>On useita mekanismeja, joiden avulla alkuperäinen <em>this</em> voidaan säilyttää, eräs näistä on metodin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">bind</a> käyttö:</p>\n<pre><code class=\"language-js\">setTimeout(arto.tervehdi.bind(arto), 1000);\n</code></pre>\n<p>Komento <code>arto.tervehdi.bind(arto)</code> luo uuden funktion, missä se on sitonut <em>this</em>:in tarkoittamaan Artoa riippumatta siitä missä ja miten metodia kutsutaan.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">Nuolifunktioiden</a> avulla on mahdollista ratkaista eräitä this:iin liittyviä ongelmia. Olioiden metodeina niitä ei kuitenkaan kannata käyttää, sillä silloin <em>this</em> ei toimi ollenkaan. Palaamme nuolifunktioiden this:in käyttäytymiseen myöhemmin.</p>\n<p>Jos haluat ymmärtää paremmin javascriptin <em>this</em>:in toimintaa, löytyy internetistä runsaasti materiaalia aiheesta. Esim. <a href=\"https://egghead.io\">egghead.io</a>:n 20 minuutin screencastsarja <a href=\"https://egghead.io/courses/understand-javascript-s-this-keyword-in-depth\">Understand JavaScript's this Keyword in Depth</a> on erittäin suositeltava!</p>\n<h3>Luokat</h3>\n<p>Kuten aiemmin mainittiin, Javascriptissä ei ole olemassa olio-ohjelmointikielten luokkamekanismia. Javascriptissa on kuitenkin ominaisuuksia, jotka mahdollistavat olio-ohjelmoinnin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\">luokkien</a> \"simuloinnin\". Emme mene nyt sen tarkemmin Javascriptin olioiden taustalla olevaan <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">prototyyppiperintämekanismiin</a>.</p>\n<p>Tutustumme kuitenkin pikaisesti ES6:n myötä Javascriptiin tulleeseen <em>luokkasyntaksiin</em>, joka helpottaa oleellisesti luokkien (tai luokan kaltaisten asioiden) määrittelyä Javascriptissa.</p>\n<p>Seuraavassa on määritelty \"luokka\" Henkilö ja sille kaksi Henkilö-oliota:</p>\n<pre><code class=\"language-js\">class Henkilo {\n  constructor(nimi, ika) {\n    this.nimi = nimi;\n    this.ika = ika;\n  }\n  tervehdi() {\n    console.log('hello, my name is', this.nimi);\n  }\n}\n\nconst arto = new Henkilo('Arto Hellas', 35);\narto.tervehdi();\n\nconst jami = new Henkilo('Jami Kousa', 21);\njami.tervehdi();\n</code></pre>\n<p>Syntaksin osalta luokat ja niistä luodut oliot muistuttavat erittäin paljon esim. Javan olioita. Käyttäytymiseltäänkin ne ovat aika lähellä Javan olioita. Perimmiltään kyseessä on kuitenkin edelleen Javascriptin <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance\">prototyyppiperintään</a> perustuvista olioista. Molempien olioiden todellinen tyyppi on <em>Object</em> sillä Javascriptissä ei perimmiltään ole muita tyyppejä kuin <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\">Boolean, Null, Undefined, Number, String, Symbol ja Object</a></p>\n<p>Luokkasyntaksin tuominen Javascriptiin on osin kiistelty lisäys, ks. esim. <a href=\"https://github.com/joshburgess/not-awesome-es6-classes\">Not Awesome: ES6 Classes</a> tai <a href=\"https://medium.com/@rajaraodv/is-class-in-es6-the-new-bad-part-6c4e6fe1ee65\">Is “Class” In ES6 The New “Bad” Part?</a></p>\n<p>ES6:n luokkasyntaksia käytetään kuitenkin paljon Reactissa ja Node.js:ssä ja siksi mekin käytämme sitä sopivissa määrin. Olio-ohjelmointimainen luokkahierarkioiden luominen ei kuitenkaan ole Reactin eikä tämän kurssin suositeltavan hengen mukaista. Reactia ohjelmoitaessa pyritään enemmän funktionaaliseen ohjelmointityyliin.</p>\n<h3>Javascript-materiaalia</h3>\n<p>Javascriptistä löytyy verkosta suuret määrät sekä hyvää että huonoa materiaalia. Tällä sivulla lähes kaikki Javascriptin ominaisuuksia käsittelevät linkit ovat <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\">Mozillan javascript -materiaaliin</a>.</p>\n<p>Mozillan sivuilta kannattaa lukea oikeastaan välittömästi <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript\">A re-introduction to JavaScript (JS tutorial)</a>.</p>\n<p>Jos haluat tutustua todella syvällisesti Javascriptiin, löytyy internetistä ilmaiseksi mainio kirjasarja <a href=\"https://github.com/getify/You-Dont-Know-JS\">You-Dont-Know-JS</a></p>\n<p><a href=\"https://egghead.io\">egghead.io</a>:lla on tarjolla runsaasti laadukkaita screencasteja Javascriptista, Reactista ym. kiinnostavasta. Valitettavasti materiaali on osittain maksullista.</p>\n<h2>Paluu Reactin äärelle</h2>\n<p>Palataan jälleen Reactin pariin.</p>\n<p>Aiemmassa esimerkissämme käytimme <a href=\"https://reactjs.org/docs/components-and-props.html#functional-and-class-components\">funktionaalisia</a> komponentteja, eli määrittelimme kaikki komponentit nuolifunktioiden avulla, esim:</p>\n<pre><code class=\"language-react\">const Hello = (props) => {\n  return (\n    &#x3C;div>\n      &#x3C;p>Hello {props.name}, you are {props.age} years old&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Toinen tapa komponenttien määrittelyyn on käyttää luokkasyntaksia. Tällöin komponentti määritellään luokaksi, joka perii <a href=\"https://reactjs.org/docs/react-component.html\">React.Component</a>-luokan.</p>\n<p>Muutetaan esimerkkisovelluksen komponentti <em>Hello</em> -luokaksi seuraavasti:</p>\n<pre><code class=\"language-react\">class Hello extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;p>Hello {this.props.name}, you are {this.props.age} years old&#x3C;/p>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Luokkakomponenttien tulee määritellä ainakin metodi <em>render</em>, joka palauttaa komponentin ulkoasun määrittelevät React-elementit eli käytännössä JSX:n.</p>\n<p>Luokkakomponentissa viitataan komponentin <em>propseihin</em> this-viitteen kautta.\nEli koska komponenttia käytetään seuraavasti</p>\n<pre><code class=\"language-html\">&#x3C;Hello name=\"Arto\" age={36} />\n</code></pre>\n<p>päästään nimeen ja ikään käsiksi luokkamuotoisen komponentin sisällä viittaamalla <em>this.props.name</em> ja <em>this.props.age</em>. Huomaa ero funktionaaliseen komponenttiin!</p>\n<p>Luokkakomponenteille voidaan tarvittaessa määritellä muitakin metodeja ja \"oliomuuttujia\", eli kenttiä.</p>\n<p>Voisimme esim. määritellä metodin seuraavasti:</p>\n<pre><code class=\"language-react\">class Hello extends React.Component {\n  bornYear() {\n    const yearNow = new Date().getFullYear()\n    return yearNow - this.props.age\n  }\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;p>\n          Hello {this.props.name}, you are {this.props.age} years old &#x3C;br />\n          So you were probably born {this.bornYear()}\n        &#x3C;/p>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Metodia kutsutaan render:in sisältä käyttäen <em>this</em>-viitettä syntaksilla <code>this.bornYear()</code>.</p>\n<p>Tässä tilanteessa ei kuitenkaan ole varsinaisesti mitään hyötyä määritellä apufunktiota <em>bornYear</em> metodiksi, joten parempi olisi määritellä se metodin <em>render</em> sisäisenä apumetodina:</p>\n<pre><code class=\"language-react\">class Hello extends React.Component {\n  render() {\n    const bornYear = () => {\n      const yearNow = new Date().getFullYear()\n      return yearNow - this.props.age\n    }\n\n    return (\n      &#x3C;div>\n        &#x3C;p>\n          Hello {this.props.name}, you are {this.props.age} years old &#x3C;br />\n          So you were probably born {bornYear()}\n        &#x3C;/p>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Huomaa, että nyt metodia <em>ei</em> kutsuta viitteen <em>this</em> kautta, vaan syntaksilla <code>bornYear()</code>, sillä metodi ei ole komponentin eli <em>this</em>:in tasolla määritelty. Metodia <em>bornYear</em> ei nyt voi kutsua mistään muualta kuin metodin <em>render</em> sisältä, sillä se ei näy renderin ulkopuolelle.</p>\n<p>Ennen kuin siirrymme eteenpäin, tarkastellaan erästä pientä, mutta käyttökelpoista ES6:n mukanaan tuomaa uutta piirrettä Javascriptissä, eli sijoittamisen yhteydessä tapahtuvaa <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destrukturointia</a>.</p>\n<p>Jouduimme äskeisessä koodissa viittaamaan propseina välitettyyn dataan hieman ikävästi muodossa <em>this.props.name</em> ja <em>this.props.age</em>. Näistä <em>this.props.age</em> pitää toistaa metodissa <em>render</em> kahteen kertaan.</p>\n<p>Koska <em>this.props</em> on nyt olio</p>\n<pre><code class=\"language-js\">this.props = {\n  name: 'Arto Hellas',\n  age: 35,\n};\n</code></pre>\n<p>voimme suoraviivaistaa metodia <em>render</em> siten, että sijoitamme kenttien arvot muuttujiin <em>name</em> ja <em>age</em> jonka jälkeen niitä on mahdollista käyttää koodissa suoraan:</p>\n<pre><code class=\"language-react\">render() {\n  const name = this.props.name\n  const age = this.props.age\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    &#x3C;div>\n      &#x3C;p>\n        Hello {name}, you are {age} years old &#x3C;br />\n        So you were probably born {bornYear()}\n      &#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Huomaa, että olemme myös hyödyntäneet nuolifunktion kompaktimpaa kirjoitustapaa metodin <em>bornYear</em> määrittelyssä.</p>\n<p>Destrukturointi tekee asian vielä helpommaksi, sen avulla voimme \"kerätä\" olion oliomuuttujien arvot suoraan omiin yksittäisiin muuttujiin:</p>\n<pre><code class=\"language-react\">class Hello extends React.Component {\n  render() {\n    const {name, age} = this.props\n    const bornYear = () => new Date().getFullYear() - age\n\n    return (\n      &#x3C;div>\n        &#x3C;p>\n          Hello {name}, you are {age} years old &#x3C;br />\n          So you were probably born {bornYear()}\n        &#x3C;/p>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Eli koska</p>\n<pre><code class=\"language-js\">this.props = {\n  name: 'Arto Hellas',\n  age: 35,\n};\n</code></pre>\n<p>saa <code> const {name, age} = this.props</code> aikaan sen, että <em>name</em> saa arvon 'Arto Hellas' ja <em>age</em> arvon 35.</p>\n<p>Komponentti <em>Hello</em> on oikeastaan luonteeltaan sellainen, että sitä ei ole järkevää määritellä luokkasyntaksilla. Reactin best practice onkin käyttää funktioiden avulla määriteltyjä komponentteja aina kuin mahdollista.</p>\n<h3>Sivun uudelleenrenderöinti</h3>\n<p>Toistaiseksi tekemämme sovellukset ovat olleet sellaisia, että kun niiden komponentit on kerran renderöity, niiden ulkoasua ei ole enää voinut muuttaa. Entä jos haluaisimme toteuttaa laskurin, jonka arvo kasvaa esim. ajan kuluessa tai nappien painallusten yhteydessä?</p>\n<p>Aloitetaan seuraavasta rungosta:</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const {counter} = props\n  return (\n    &#x3C;div>{counter.value}&#x3C;/div>\n  )\n}\n\nconst counter = {\n  value: 1\n}\n\nReactDOM.render(\n  &#x3C;App counter={counter} />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Sovelluksen juurikomponentille siis annetaan viite laskuriin. Juurikomponentti renderöi arvon ruudulle. Entä laskurin arvon muuttuessa? Jos lisäämme ohjelmaan esim. komennon</p>\n<pre><code class=\"language-react\">counter.value += 1\n</code></pre>\n<p>ei komponenttia kuitenkaan renderöidä uudelleen. Voimme saada komponentin uudelleenrenderöitymään kutsumalla uudelleen metodia <em>ReactDOM.render</em>, esim. seuraavasti</p>\n<pre><code class=\"language-react\">const App = (props) => {\n  const {counter} = props\n  return (\n    &#x3C;div>{counter.value}&#x3C;/div>\n  )\n}\n\nconst counter = {\n  value: 1\n}\n\nconst renderoi = () => {\n  ReactDOM.render(\n    &#x3C;App counter={counter} />,\n    document.getElementById('root')\n  )\n}\n\nrenderoi()\ncounter.value += 1\nrenderoi()\ncounter.value += 1\nrenderoi()\n</code></pre>\n<p>Copypastea vähentämään on komponentin renderöinti kääritty funktioon <em>renderoi</em>.</p>\n<p>Nyt komponentti renderöityy kolme kertaa, saaden ensin arvon 1, sitten 2 ja lopulta 3. 1 ja 2 tosin ovat ruudulla niin vähän aikaa, että niitä ei ehdi havaita.</p>\n<p>Hieman mielenkiintoisempaan toiminnallisuuteen pääsemme tekemällä renderöinnin ja laskurin kasvatuksen toistuvasti sekunnin välein käyttäen <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\">SetInterval</a>:</p>\n<pre><code class=\"language-js\">setInterval(() => {\n  renderoi();\n  counter.value += 1;\n}, 1000);\n</code></pre>\n<p><em>ReactDOM.render</em>-metodin toistuva kutsuminen ei kuitenkaan ole suositeltu tapa päivittää komponentteja. Tutustutaan seuraavaksi järkevämpään tapaan.</p>\n<h3>Tilallinen komponentti</h3>\n<p>Muutetaan esimerkkisovelluksen komponentti <em>App</em> luokkaperustaiseksi:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      counter: 1\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>{this.state.counter}&#x3C;/div>\n    )\n  }\n}\n\nReactDOM.render(\n  &#x3C;App />,\n  document.getElementById('root')\n)\n</code></pre>\n<p>Komponentilla on nyt metodin <em>render</em> lisäksi <em>konstruktori</em>. Komponentin konstruktori saa parametrikseen sille välitettävät muuttujat parametrin <em>props</em> välityksellä, konstruktorin ensimmäisen rivin on oltava kutsu <code>super(props)</code>.</p>\n<p>Luokkiin perustuvilla komponenteilla voi olla <em>tila</em>, joka talletetaan muuttujaan <em>state</em>.</p>\n<p>Konstruktori määrittelee komponentin alkutilan olevan:</p>\n<pre><code class=\"language-js\">{\n  counter: 1;\n}\n</code></pre>\n<p>Eli tila sisältää kentän <em>counter</em>, jonka arvo on 1. React-komponenttien tilaa, eli muuttujaa <em>this.state</em> <strong>ei saa päivittää suoraan</strong>, tilan päivitys on tehtävä <strong>aina</strong> funktion <a href=\"https://reactjs.org/docs/faq-state.html#what-does-setstate-do\">setState</a> avulla. Metodin kutsuminen päivittää tilan <em>ja</em> aiheuttaa komponentin uuden renderöinnin (ellei sitä ole estetty myöhemmin esiteltävällä tavalla). Uudelleenrenderöinnin yhteydessä myös kaikki komponentin sisältämät alikomponentit renderöidään.</p>\n<p>Muutetaan komponenttia <em>App</em> siten, että konstruktorissa käynnistetään ajastin, joka kutsuu funktiota <em>setState</em> toistuvasti sekunnin välein korottaen laskurin arvoa aina yhdellä:</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      counter: 1\n    }\n\n    setInterval(() => {\n      this.setState({ counter: this.state.counter + 1 })\n    }, 1000)\n  }\n  render() {\n    return (\n      &#x3C;div>{this.state.counter}&#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>Ruudulle renderöity laskurin arvo päivittyy sillä aina komponentin tilan muuttuessa <em>React</em> kutsuu komponentin metodia <em>render</em>.</p>\n<p>Jos komponentti ei renderöidy vaikka sen omasta mielestä pitäisi, tai se renderöityy \"väärään aikaan\", debuggaamista auttaa joskus metodiin <em>render</em> liitetty konsoliin tulostus. Esim. jos lisäämme koodiin seuraavan,</p>\n<pre><code class=\"language-react\">class App extends React.Component {\n  // ...\n  render() {\n    console.log('renderöidään', this.state.counter)\n    return (\n      &#x3C;div>{this.state.counter}&#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<p>on konsolista helppo seurata metodin <em>render</em> kutsuja:</p>\n<picture><img src=\"/static/5a2248873f442ef831d6561303c99b41/14be6/27a.png\" srcset=\"/static/5a2248873f442ef831d6561303c99b41/4cce7/27a.png 200w,\n/static/5a2248873f442ef831d6561303c99b41/bae5f/27a.png 400w,\n/static/5a2248873f442ef831d6561303c99b41/14be6/27a.png 800w,\n/static/5a2248873f442ef831d6561303c99b41/1b35a/27a.png 1200w,\n/static/5a2248873f442ef831d6561303c99b41/9ee03/27a.png 1600w,\n/static/5a2248873f442ef831d6561303c99b41/c659e/27a.png 1668w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>","frontmatter":{"path":"/osa1/react","mainImage":{"publicURL":"/static/osa5-8edc6044aad809a3143dc36c5e7f3b4c.png"}}}},"pageContext":{}}